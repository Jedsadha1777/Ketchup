<!DOCTYPE html>
<html lang="en">

<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Orthogonal Pathfinding Demo</title>
   <style>
       * {
           margin: 0;
           padding: 0;
           box-sizing: border-box;
       }

       body {
           font-family: Arial, sans-serif;
           background: #1a1a1a;
           overflow: hidden;
       }

       .container {
           width: 100vw;
           height: 100vh;
           position: relative;
           background: #1e1e1e;
       }

       .controls {
           position: absolute;
           bottom: 20px;
           left: 20px;
           background: rgba(0, 0, 0, 0.9);
           color: white;
           padding: 20px;
           border-radius: 8px;
           z-index: 100;
       }

       .controls button {
           background: #0066cc;
           color: white;
           border: none;
           padding: 8px 12px;
           border-radius: 4px;
           margin: 3px;
           cursor: pointer;
           font-size: 11px;
       }

       .controls button:hover {
           background: #0088ff;
       }

       .controls input[type="file"] {
           margin: 10px 0;
           padding: 8px;
           background: white;
           border: 1px solid #ccc;
           border-radius: 4px;
           width: 100%;
       }

       #runtime-canvas {
           position: absolute !important;
           top: 0 !important;
           left: 0 !important;
           z-index: 1 !important;
           background: #f8f9fa !important;
       }

       .info {
           position: absolute;
           top: 20px;
           right: 20px;
           background: rgba(0, 0, 0, 0.9);
           color: white;
           padding: 15px;
           border-radius: 8px;
           font-size: 12px;
       }
   </style>
</head>

<body>
   <div class="container">
       <canvas id="runtime-canvas"></canvas>

       <div class="controls">
            <h3>üó∫Ô∏è Orthogonal Pathfinding</h3>
            <input type="file" id="file-input" accept=".json">
            <button onclick="loadFile()">üìÅ Load JSON</button>

            <div style="margin: 10px 0;">
                <label style="color: white; display: block; margin-bottom: 4px;">From Waypoint:</label>
                <select id="from-waypoint" style="width: 100%; padding: 4px;">
                    <option value="">Select waypoint...</option>
                </select>
            </div>

            <div style="margin: 10px 0;">
                <label style="color: white; display: block; margin-bottom: 4px;">To Waypoint:</label>
                <select id="to-waypoint" style="width: 100%; padding: 4px;">
                    <option value="">Select waypoint...</option>
                </select>
            </div>

            <button onclick="findPaths()">üîç Find Path</button>
            <button onclick="clearPaths()">üßπ Clear</button>
            <button onclick="toggleDebug()">üîß Debug</button>
            <button onclick="loadSample()">üéØ Sample</button>

            <div style="margin: 10px 0; padding-top: 10px; border-top: 1px solid #555;">
               <div style="color: #aaa; font-size: 10px;">
                    üñ±Ô∏è Right-click & drag or Ctrl+drag to pan
               </div>
            </div>

            <!-- Toggle visibility controls -->
            <div style="margin: 10px 0; border-top: 1px solid #555; padding-top: 10px;">
                <label style="color: white; display: block; margin-bottom: 8px; font-size: 12px;">Visibility:</label>
                <div style="display: flex; flex-wrap: wrap; gap: 5px;">
                    <label style="color: white; font-size: 11px; display: flex; align-items: center;">
                        <input type="checkbox" id="show-corridors" checked style="margin-right: 4px;">
                        Corridors
                    </label>
                    <label style="color: white; font-size: 11px; display: flex; align-items: center;">
                        <input type="checkbox" id="show-walls" checked style="margin-right: 4px;">
                        Walls
                    </label>
                    <label style="color: white; font-size: 11px; display: flex; align-items: center;">
                        <input type="checkbox" id="show-waypoints" checked style="margin-right: 4px;">
                        Waypoints
                    </label>
                </div>
            </div>

            <div style="margin-top: 10px;">
                <label style="display: block; color: white; margin-bottom: 4px;">Object Size:</label>
                <input type="range" id="object-size" min="1" max="40" value="1" style="width: 100%;">
                <span id="size-value" style="color: white; font-size: 10px;">1px</span>
            </div>
        </div>

       <div class="info">
           <div>Corridors: <span id="corridor-count">0</span></div>
           <div>Walls: <span id="wall-count">0</span></div>
           <div>Waypoints: <span id="waypoint-count">0</span></div>
           <div>Paths: <span id="path-count">0</span></div>
           <div>Object Size: <span id="current-size">5</span>px</div>
           <div>Min Corridor: <span id="min-corridor">0</span>px</div>
           <div>Zoom: <span id="zoom-level">100%</span></div>
       </div>
   </div>

   <script type="module">
       import { RuntimeViewer } from './runtime/RuntimeViewer.js';

       let viewer = null;
       let corridors = [];
       let walls = [];
       let waypoints = [];
       let paths = [];
       let gridSize = 5;
       let objectSize = 5;
       let showDebug = false;

       let showCorridors = true;
        let showWalls = true;
        let showWaypoints = true;

        // Pan state variables
        let isPanning = false;
        let lastPanX = 0;
        let lastPanY = 0;

       function updateInfo() {
           document.getElementById('corridor-count').textContent = corridors.length;
           document.getElementById('wall-count').textContent = walls.length;
           document.getElementById('waypoint-count').textContent = waypoints.length;
           document.getElementById('path-count').textContent = paths.length;
           document.getElementById('current-size').textContent = objectSize;

           let minDimension = 0;
           if (corridors.length > 0) {
               minDimension = Math.min(...corridors.map(c => Math.min(c.width, c.height)));
           }
           document.getElementById('min-corridor').textContent = minDimension.toFixed(1);

           const zoom = viewer ? Math.round(viewer.zoom * 100) : 100;
           document.getElementById('zoom-level').textContent = zoom + '%';
       }

       document.addEventListener('DOMContentLoaded', () => {
           const canvas = document.getElementById('runtime-canvas');
           viewer = new RuntimeViewer(canvas, {
               showGrid: false,
               enableEvents: true,
               enableInteraction: true
           });

           // Override viewer's render method to always include paths
           const originalRender = viewer.render.bind(viewer);
           viewer.render = function() {
               originalRender();
               if (paths.length > 0) drawPaths();
               if (showDebug) drawCorridorBuffers();
           };

           canvas.addEventListener('wheel', (e) => {
               // Let viewer handle zoom first, then redraw paths
               setTimeout(() => {
                   viewer.render();
               }, 10);
            });

           // Add pan functionality
           canvas.addEventListener('mousedown', handlePanStart);
           canvas.addEventListener('mousemove', handlePanMove);
           canvas.addEventListener('mouseup', handlePanEnd);
           canvas.addEventListener('mouseleave', handlePanEnd);
           
           // Prevent context menu on right click
           canvas.addEventListener('contextmenu', (e) => {
               e.preventDefault();
           });

           function handlePanStart(e) {
               // Start panning on right click or middle click or ctrl+left click
               if (e.button === 2 || e.button === 1 || (e.button === 0 && (e.ctrlKey || e.metaKey))) {
                   e.preventDefault();
                   isPanning = true;
                   lastPanX = e.clientX;
                   lastPanY = e.clientY;
                   canvas.style.cursor = 'grabbing';
               }
           }

           function handlePanMove(e) {
               if (!isPanning) {
                   // Show grab cursor when hovering and not over UI elements
                   if (e.ctrlKey || e.metaKey) {
                       canvas.style.cursor = 'grab';
                   } else {
                       canvas.style.cursor = 'default';
                   }
                   return;
               }

               e.preventDefault();
               
               // Calculate pan delta
               const deltaX = e.clientX - lastPanX;
               const deltaY = e.clientY - lastPanY;
               
               // Update viewer pan position
               viewer.panX += deltaX;
               viewer.panY += deltaY;
               
               // Update last position
               lastPanX = e.clientX;
               lastPanY = e.clientY;
               
               // Re-render (will automatically include paths)
               viewer.render();
           }

           function handlePanEnd(e) {
               if (isPanning) {
                   isPanning = false;
                   canvas.style.cursor = e.ctrlKey || e.metaKey ? 'grab' : 'default';
               }
           }

           window.viewer = viewer;

           const sizeSlider = document.getElementById('object-size');
           const sizeValue = document.getElementById('size-value');

           if (sizeSlider && sizeValue) {
               sizeSlider.addEventListener('input', () => {
                   objectSize = parseInt(sizeSlider.value);
                   sizeValue.textContent = objectSize + 'px';
                   updateInfo();

                   if (paths.length > 0) {
                       findPaths();
                   }
               });
           }

           // Setup visibility change handlers to redraw
           const redrawHandler = () => {
               viewer.render();
               updateInfo();
           };

           // Setup visibility toggles
            document.getElementById('show-corridors').addEventListener('change', (e) => {
                showCorridors = e.target.checked;
                viewer.setVisibility('corridors', showCorridors);
                redrawHandler();

            });

            document.getElementById('show-walls').addEventListener('change', (e) => {
                showWalls = e.target.checked;
                viewer.setVisibility('walls', showWalls);
                redrawHandler();

            });


            document.getElementById('show-waypoints').addEventListener('change', (e) => {
                showWaypoints = e.target.checked;
                viewer.setVisibility('waypoints', showWaypoints);
                redrawHandler();

            });

            updateInfo();
       });

       class OrthogonalPathfinder {
           constructor(corridors, walls, gridSize, objectSize = 20) {
               this.corridors = corridors;
               this.walls = walls;
               this.gridSize = gridSize;
               this.objectSize = objectSize;
               this.createGrid();
           }

           createGrid() {
               const bounds = this.getMapBounds();
               const cols = Math.ceil(bounds.width / this.gridSize);
               const rows = Math.ceil(bounds.height / this.gridSize);

               this.grid = [];
               this.minX = bounds.minX;
               this.minY = bounds.minY;
               this.cols = cols;
               this.rows = rows;

               for (let y = 0; y < rows; y++) {
                   this.grid[y] = [];
                   for (let x = 0; x < cols; x++) {
                       const worldX = this.minX + x * this.gridSize + this.gridSize / 2;
                       const worldY = this.minY + y * this.gridSize + this.gridSize / 2;

                       const walkable = this.canPlaceObjectAt(worldX, worldY);

                       this.grid[y][x] = {
                           x: x,
                           y: y,
                           worldX: worldX,
                           worldY: worldY,
                           walkable: walkable,
                           f: 0,
                           g: 0,
                           h: 0,
                           parent: null
                       };
                   }
               }

               let walkableCount = 0;
               for (let y = 0; y < rows; y++) {
                   for (let x = 0; x < cols; x++) {
                       if (this.grid[y][x].walkable) walkableCount++;
                   }
               }
               console.log(`Walkable cells: ${walkableCount}/${cols * rows}`);
           }

           canPlaceObjectAt(centerX, centerY) {
               const halfSize = this.objectSize / 2;

               // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡∏ä‡∏ô‡∏Å‡∏±‡∏ö wall ‡∏Å‡πà‡∏≠‡∏ô
               if (!this.isPositionClearOfWalls(centerX, centerY)) {
                   return false;
               }

               // ‡∏ñ‡πâ‡∏≤ object size ‡πÄ‡∏•‡πá‡∏Å‡∏°‡∏≤‡∏Å ‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏ß‡∏à‡πÅ‡∏Ñ‡πà‡∏à‡∏∏‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á
               if (this.objectSize < 5) {
                   for (const corridor of this.corridors) {
                       if (centerX >= corridor.x && centerX <= corridor.x + corridor.width &&
                           centerY >= corridor.y && centerY <= corridor.y + corridor.height) {
                           return true;
                       }
                   }
                   return false;
               }

               // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö object ‡πÉ‡∏´‡∏ç‡πà‡∏Å‡∏ß‡πà‡∏≤ ‡∏ï‡∏£‡∏ß‡∏à‡∏ó‡∏∏‡∏Å‡∏°‡∏∏‡∏°
               const objectCorners = [
                   { x: centerX - halfSize, y: centerY - halfSize },
                   { x: centerX + halfSize, y: centerY - halfSize },
                   { x: centerX - halfSize, y: centerY + halfSize },
                   { x: centerX + halfSize, y: centerY + halfSize }
               ];

               for (const corner of objectCorners) {
                   let cornerInCorridor = false;

                   for (const corridor of this.corridors) {
                       if (corner.x >= corridor.x && corner.x <= corridor.x + corridor.width &&
                           corner.y >= corridor.y && corner.y <= corridor.y + corridor.height) {
                           cornerInCorridor = true;
                           break;
                       }
                   }

                   if (!cornerInCorridor) {
                       return false;
                   }
               }

               return true;
           }

           isPositionClearOfWalls(centerX, centerY) {
               const halfSize = this.objectSize / 2;

               // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ object ‡πÑ‡∏°‡πà‡∏ó‡∏±‡∏ö‡∏Å‡∏±‡∏ö wall
               const objectBounds = {
                   left: centerX - halfSize,
                   right: centerX + halfSize,
                   top: centerY - halfSize,
                   bottom: centerY + halfSize
               };

               for (const wall of this.walls) {
                   const wallBounds = {
                       left: wall.x,
                       right: wall.x + wall.width,
                       top: wall.y,
                       bottom: wall.y + wall.height
                   };

                   // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô (collision detection)
                   if (objectBounds.left < wallBounds.right &&
                       objectBounds.right > wallBounds.left &&
                       objectBounds.top < wallBounds.bottom &&
                       objectBounds.bottom > wallBounds.top) {
                       return false; // ‡∏ä‡∏ô‡∏Å‡∏±‡∏ö wall
                   }
               }

               return true; // ‡πÑ‡∏°‡πà‡∏ä‡∏ô‡∏Å‡∏±‡∏ö wall ‡πÉ‡∏î‡πÜ
           }

           getMapBounds() {
               let minX = Infinity, minY = Infinity;
               let maxX = -Infinity, maxY = -Infinity;

               // ‡∏£‡∏ß‡∏° bounds ‡∏Ç‡∏≠‡∏á corridors ‡πÅ‡∏•‡∏∞ walls
               [...this.corridors, ...this.walls].forEach(obj => {
                   minX = Math.min(minX, obj.x);
                   minY = Math.min(minY, obj.y);
                   maxX = Math.max(maxX, obj.x + obj.width);
                   maxY = Math.max(maxY, obj.y + obj.height);
               });

               return {
                   minX: minX - this.gridSize * 2,
                   minY: minY - this.gridSize * 2,
                   width: maxX - minX + this.gridSize * 4,
                   height: maxY - minY + this.gridSize * 4
               };
           }

           worldToGrid(worldX, worldY) {
               const x = Math.floor((worldX - this.minX + this.gridSize / 2) / this.gridSize);
               const y = Math.floor((worldY - this.minY + this.gridSize / 2) / this.gridSize);
               return { x, y };
           }

           getNode(x, y) {
               if (x < 0 || x >= this.cols || y < 0 || y >= this.rows) {
                   return null;
               }
               return this.grid[y][x];
           }

           getNeighbors(node) {
               const neighbors = [];
               const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];

               dirs.forEach(([dx, dy]) => {
                   const neighbor = this.getNode(node.x + dx, node.y + dy);
                   if (neighbor && neighbor.walkable) {
                       neighbors.push(neighbor);
                   }
               });

               return neighbors;
           }

           heuristic(a, b) {
               // ‡πÉ‡∏ä‡πâ Manhattan distance ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô (‡πÑ‡∏°‡πà‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡∏ó‡πÅ‡∏¢‡∏á)
               return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
           }

           findPath(startWorld, endWorld) {
               if (!this.canPlaceObjectAt(startWorld.x, startWorld.y)) {
                   console.log(`Cannot place object at start waypoint`);
                   return null;
               }

               if (!this.canPlaceObjectAt(endWorld.x, endWorld.y)) {
                   console.log(`Cannot place object at end waypoint`);
                   return null;
               }

               const start = this.worldToGrid(startWorld.x, startWorld.y);
               const end = this.worldToGrid(endWorld.x, endWorld.y);

               const startNode = this.getNode(start.x, start.y);
               const endNode = this.getNode(end.x, end.y);

               if (!startNode || !endNode || !startNode.walkable || !endNode.walkable) {
                   console.log('Start or end node not walkable');
                   return null;
               }

               // Reset all nodes
               for (let y = 0; y < this.rows; y++) {
                   for (let x = 0; x < this.cols; x++) {
                       const node = this.grid[y][x];
                       node.f = 0;
                       node.g = 0;
                       node.h = 0;
                       node.parent = null;
                   }
               }

               const openSet = [startNode];
               const closedSet = new Set();

               startNode.g = 0;
               startNode.h = this.heuristic(startNode, endNode);
               startNode.f = startNode.h;

               while (openSet.length > 0) {
                   let current = openSet[0];
                   let currentIndex = 0;

                   for (let i = 1; i < openSet.length; i++) {
                       if (openSet[i].f < current.f ||
                           (openSet[i].f === current.f && openSet[i].h < current.h)) {
                           current = openSet[i];
                           currentIndex = i;
                       }
                   }

                   openSet.splice(currentIndex, 1);
                   closedSet.add(current);

                   if (current === endNode) {
                       const path = [];
                       let temp = current;
                       while (temp) {
                           path.push({ x: temp.worldX, y: temp.worldY });
                           temp = temp.parent;
                       }
                       return this.optimizePath(path.reverse());
                   }

                   const neighbors = this.getNeighbors(current);
                   neighbors.forEach(neighbor => {
                       if (closedSet.has(neighbor)) return;

                       let moveCost = 1;

                       // ‡πÉ‡∏´‡πâ weight ‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÑ‡∏õ‡∏´‡∏≤ goal
                       const toEndX = endNode.x - current.x;
                       const toEndY = endNode.y - current.y;
                       const moveX = neighbor.x - current.x;
                       const moveY = neighbor.y - current.y;

                       // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏î‡∏¥‡∏ô‡πÑ‡∏õ‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö goal ‡πÉ‡∏´‡πâ cost ‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤
                       if ((toEndX > 0 && moveX > 0) || (toEndX < 0 && moveX < 0) ||
                           (toEndY > 0 && moveY > 0) || (toEndY < 0 && moveY < 0)) {
                           moveCost = 0.99;
                       }

                       const tentativeG = current.g + moveCost;

                       if (!openSet.includes(neighbor)) {
                           openSet.push(neighbor);
                       } else if (tentativeG >= neighbor.g) {
                           return;
                       }

                       neighbor.parent = current;
                       neighbor.g = tentativeG;
                       neighbor.h = this.heuristic(neighbor, endNode);
                       neighbor.f = neighbor.g + neighbor.h;
                   });
               }

               console.log('No path found');
               return null;
           }

           optimizePath(path) {
               if (path.length <= 2) return path;

               const simplified = [path[0]];

               for (let i = 1; i < path.length - 1; i++) {
                   const prev = path[i - 1];
                   const curr = path[i];
                   const next = path[i + 1];

                   const dir1 = {
                       x: Math.sign(curr.x - prev.x),
                       y: Math.sign(curr.y - prev.y)
                   };
                   const dir2 = {
                       x: Math.sign(next.x - curr.x),
                       y: Math.sign(next.y - curr.y)
                   };

                   if (dir1.x !== dir2.x || dir1.y !== dir2.y) {
                       simplified.push(curr);
                   }
               }
               simplified.push(path[path.length - 1]);

               return simplified;
           }
       }

       function calculateLineWidth() {
           return objectSize;
       }

       window.loadFile = function () {
           const fileInput = document.getElementById('file-input');
           const file = fileInput.files[0];

           if (!file) {
               alert('Please select a JSON file');
               return;
           }

           const reader = new FileReader();
           reader.onload = function (e) {
               try {
                   const mapData = JSON.parse(e.target.result);
                   viewer.loadMapData(mapData);
                   extractCorridorsWallsAndWaypoints();
                   updateInfo();
               } catch (error) {
                   alert('Error loading JSON: ' + error.message);
               }
           };

           reader.readAsText(file);
       };

       window.loadSample = function () {
           const sampleData = {"version":1,"objects":[{"id":0,"type":"image","mapType":"image","x":440.84322648810496,"y":159.24109616070547,"w":980,"h":617.7881257275902,"color":"#000000","label":"","objectId":"","extra":{"src":"data:image/png;base64,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BApQgAIUoAAFKEABClCAAn4QYLDlB1SukgIUoAAFKEABClCAAhSgAIMtngMUoAAFKEABClCAAhSgAAX8IMBgyw+oXCUFKEABClCAAhSgAAUoQAEGWzwHKEABClCAAhSgAAUoQAEK+EGAwZYfULlKClCAAhSgAAUoQAEKUIACDLZ4DlCAAhSgAAUoQAEKUIACFPCDAIMtP6BylRSgAAUoQAEKUIACFKAABRhs8RygAAUoQAEKUIACFKAABSjgBwEGW35A5SopQAEKUIACFKAABShAAQow2OI5QAEKUIACFKAABShAAQpQwA8CDLb8gMpVUoACFKAABShAAQpQgAIUYLDFc4ACFKAABShAAQpQgAIUoIAfBBhs+QGVq6QABShAAQpQgAIUoAAFKMBgi+cABShAAQpQgAIUoAAFKEABPwgw2PIDKldJAQpQgAIUoAAFKEABClCAwRbPAQpQgAIUoAAFKEABClCAAn4QYLDlB1SukgIUoAAFKEABClCAAhSgAIMtngMUoAAFKEABClCAAhSgAAX8IMBgyw+oXCUFKEABClCAAhSgAAUoQAEGWzwHKEABClCAAhSgAAUoQAEK+EGAwZYfULlKClCAAhSgAAUoQAEKUIACDLZ4DlCAAhSgAAUoQAEKUIACFPCDAIMtP6BylRSgAAUoQAEKUIACFKAABRhs8RygAAUoQAEKUIACFKAABSjgBwEGW35A5SopQAEKUIACFKAABShAAQow2OI5QAEKUIACFKAABShAAQpQwA8CDLb8gMpVUoACFKAABShAAQpQgAIUYLDFc4ACFKAABShAAQpQgAIUoIAfBBhs+QGVq6QABShAAQpQgAIUoAAFKMBgi+cABShAAQpQgAIUoAAFKEABPwgw2PIDKldJAQpQgAIUoAAFKEABClCAwRbPAQpQgAIUoAAFKEABClCAAn4QYLDlB1SukgIUoAAFKEABClCAAhSgAIMtngMUoAAFKEABClCAAhSgAAX8IMBgyw+oXCUFKEABClCAAhSgAAUoQAEGWzwHKEABClCAAhSgAAUoQAEK+EGAwZYfULlKClCAAhSgAAUoQAEKUIACDLZ4DlCAAhSgAAUoQAEKUIACFPCDAIMtP6BylRSgAAUoQAEKUIACFKAABRhs8RygAAUoQAEKUIACFKAABSjgBwEGW35A5SopQAEKUIACFKAABShA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2XJ3CbF8DQiIctWzS2CDuPoHopR1TNFXP68fz30SIAESIAESIAESIAESONYEzGGBY31n3o8ESIAESIAESIAESIAESIAEvJgAlS0vFi6rRgIkQAIkQAIkQAIkQAIk4DoCVLZcx553JgESIAESIAESIAESIAES8GICVLa8WLisGgmQAAmQAAmQAAmQAAmQgOsIUNlyHXvemQRIgARIgARIgARIgARIwIsJUNnyYuGyaiRAAiRAAiRAAiRAAiRAAq4jQGXLdex5ZxIgARIgARIgARIgARIgAS8mQGXLi4XLqpEACZAACZAACZAACZAACbiOAJUt17HnnUmABEiABEiABEiABEiABLyYAJUtLxYuq0YCJEACJEACJEACJEACJOA6AlS2XMeedyYBEiABEiABEiABEiABEvBiAlS2vFi4rBoJkAAJkAAJkAAJkAAJkIDrCFhdd+um7+zj1xHWuCFNn2RsswR8/Ls1e85dTvgE9nZD2VoMPD5+KW5YPlU83yijjO66Y4ufCkdMrlsVz2KNN8rjG3IuLD5BxrE77NQvnzuUp7ky+EZfBDgqmzvN+CYIWHzCm4h1syifCLd83/n4dTBAWWMvVPu1xrE77PgE9HaHYrRaBr0d5Wg1HRPUI+ATVu/AfXcHX9wb5WXVblXArt3N/9uzB3ZF564JblW+jsfHurQ8FocKLi0Bb04CJEACJEACJEACJEACJEACXkiAZoReKFRWiQRIgARIgARIgARIgARIwPUEqGy5XgYsAQmQAAmQAAmQAAmQAAmQgBcSoLLlhUJllUiABEiABEiABEiABEiABFxPgMqW62XAEpAACZAACZAACZAACZAACXghASpbXihUVokESIAESIAESIAESIAESMD1BKhsuV4GLAEJkAAJkAAJkAAJkAAJkIAXEqCy5YVCZZVIgARIgARIgARIgARIgARcT4DKlutlwBKQAAmQAAmQAAmQAAmQAAl4IQEqW14oVFaJBEiABEiABEiABEiABEjA9QSobLleBiwBCZAACZAACZAACZAACZCAFxKgsuWFQmWVSIAESIAESIAESIAESIAEXE+AypbrZcASkAAJkAAJkAAJkAAJkAAJeCEBKlteKFRWiQRIgARIgARIgARIgARIwPUEqGy5XgYsAQmQAAmQAAmQAAmQAAmQgBcSoLLlhUJllUiABEiABEiABEiABEiABFxPgMqW62XAEpAACZAACZAACZAACZAACXghASpbXihUVokESIAESIAESIAESIAESMD1BKhsuV4GLAEJkAAJkAAJkAAJkAAJkIAXEqCy5YVCZZVIgARIgARIgARIgARIgARcT4DKlutlwBKQAAmQAAmQAAmQAAmQAAl4IQEqW14oVFaJBEiABEiABEiABEiABEjA9QSobLleBiwBCZAACZAACZAACZAACZCAFxKgsuWFQmWVSIAESIAESIAESIAESIAEXE+AypbrZcASkAAJkAAJkAAJkAAJkAAJeCEBKlteKFRWiQRIgARIgARIgARIgARIwPUEqGy5XgYsAQmQAAmQAAmQAAmQAAmQgBcSoLLlhUJllUiABEiABEiABEiABEiABFxPgMqW62XAEpAACZAACZAACZAACZAACXghASpbXihUVokESIAESIAESIAESIAESMD1BKhsuV4GLAEJkAAJkAAJkAAJkAAJkIAXEqCy5YVCZZVIgARIgARIgARIgARIgARcT4DKlutlwBKQAAmQAAmQAAmQAAmQAAl4IQEqW14oVFaJBEiABEiABEiABEiABEjA9QSobLleBiwBCZAACZAACZAACZAACZCAFxKgsuWFQmWVSIAESIAESIAESIAESIAEXE+AypbrZcASkAAJkAAJkAAJkAAJkAAJeCEBKlteKFRWiQRIgARIgARIgARIgARIwPUE/h9E/DwLsFq+TAAAAABJRU5ErkJggg==","opacity":1,"fit":"contain"}},{"id":1,"type":"rectangle","mapType":"corridor","x":440,"y":220,"w":980,"h":20,"color":"#f39c12","label":"","objectId":"corridor1","extra":null},{"id":2,"type":"rectangle","mapType":"corridor","x":440,"y":680,"w":980,"h":20,"color":"#f39c12","label":"","objectId":"corridor2","extra":null},{"id":3,"type":"rectangle","mapType":"corridor","x":440,"y":440,"w":980,"h":40,"color":"#f39c12","label":"","objectId":"corridor3","extra":null},{"id":4,"type":"rectangle","mapType":"corridor","x":440,"y":220,"w":20,"h":480,"color":"#f39c12","label":"","objectId":"corridor4","extra":null},{"id":5,"type":"rectangle","mapType":"corridor","x":580,"y":220,"w":20,"h":480,"color":"#f39c12","label":"","objectId":"corridor5","extra":null},{"id":6,"type":"rectangle","mapType":"corridor","x":720,"y":220,"w":20,"h":480,"color":"#f39c12","label":"","objectId":"corridor6","extra":null},{"id":7,"type":"rectangle","mapType":"corridor","x":860,"y":220,"w":20,"h":480,"color":"#f39c12","label":"","objectId":"corridor7","extra":null},{"id":8,"type":"rectangle","mapType":"corridor","x":1000,"y":220,"w":20,"h":480,"color":"#f39c12","label":"","objectId":"corridor8","extra":null},{"id":9,"type":"rectangle","mapType":"corridor","x":1120,"y":220,"w":20,"h":480,"color":"#f39c12","label":"","objectId":"corridor9","extra":null},{"id":10,"type":"rectangle","mapType":"corridor","x":1260,"y":220,"w":20,"h":480,"color":"#f39c12","label":"","objectId":"corridor10","extra":null},{"id":11,"type":"rectangle","mapType":"corridor","x":1402.7700175644077,"y":220,"w":18.916435411802468,"h":480,"color":"#f39c12","label":"","objectId":"","extra":null},{"id":12,"type":"circle","mapType":"waypoint","x":512,"y":332,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"a38","extra":null},{"id":13,"type":"circle","mapType":"waypoint","x":512,"y":572,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"a30","extra":null},{"id":14,"type":"circle","mapType":"waypoint","x":623,"y":287,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"b42","extra":null},{"id":15,"type":"circle","mapType":"waypoint","x":624,"y":372,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"b38","extra":null},{"id":16,"type":"circle","mapType":"waypoint","x":622,"y":545,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"b32","extra":null},{"id":17,"type":"circle","mapType":"waypoint","x":622,"y":635,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"b30","extra":null},{"id":18,"type":"circle","mapType":"waypoint","x":690,"y":312,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"c39","extra":null},{"id":19,"type":"circle","mapType":"waypoint","x":690,"y":391,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"c37","extra":null},{"id":20,"type":"circle","mapType":"waypoint","x":672,"y":512,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"c33","extra":null},{"id":21,"type":"circle","mapType":"waypoint","x":672,"y":612,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"c29","extra":null},{"id":22,"type":"circle","mapType":"waypoint","x":755,"y":290,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"c42","extra":null},{"id":23,"type":"circle","mapType":"waypoint","x":755,"y":399,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"c38","extra":null},{"id":24,"type":"circle","mapType":"waypoint","x":755,"y":570,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"c35","extra":null},{"id":25,"type":"circle","mapType":"waypoint","x":823,"y":318,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"d39","extra":null},{"id":26,"type":"circle","mapType":"waypoint","x":820,"y":400,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"d37","extra":null},{"id":27,"type":"circle","mapType":"waypoint","x":826,"y":524,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"d33","extra":null},{"id":28,"type":"circle","mapType":"waypoint","x":827,"y":612,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"d29","extra":null},{"id":29,"type":"circle","mapType":"waypoint","x":889,"y":316,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"d42","extra":null},{"id":30,"type":"circle","mapType":"waypoint","x":890,"y":402,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"d40","extra":null},{"id":31,"type":"circle","mapType":"waypoint","x":912,"y":492,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"d38","extra":null},{"id":32,"type":"circle","mapType":"waypoint","x":912,"y":532,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"d36","extra":null},{"id":33,"type":"circle","mapType":"waypoint","x":932,"y":612,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"d32","extra":null},{"id":34,"type":"circle","mapType":"waypoint","x":952,"y":532,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"e35","extra":null},{"id":35,"type":"circle","mapType":"waypoint","x":961,"y":402,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"e39","extra":null},{"id":36,"type":"circle","mapType":"waypoint","x":961,"y":351,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"e41","extra":null},{"id":37,"type":"circle","mapType":"waypoint","x":958,"y":291,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"e43","extra":null},{"id":38,"type":"circle","mapType":"waypoint","x":1027,"y":313,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"e42","extra":null},{"id":39,"type":"circle","mapType":"waypoint","x":1025,"y":399,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"e40","extra":null},{"id":40,"type":"circle","mapType":"waypoint","x":1026,"y":495,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"e38","extra":null},{"id":41,"type":"circle","mapType":"waypoint","x":1023,"y":595,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"e32","extra":null},{"id":42,"type":"circle","mapType":"waypoint","x":1095,"y":291,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"f43","extra":null},{"id":43,"type":"circle","mapType":"waypoint","x":1096,"y":378,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"f39","extra":null},{"id":44,"type":"circle","mapType":"waypoint","x":1095,"y":521,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"f35","extra":null},{"id":45,"type":"circle","mapType":"waypoint","x":1097,"y":605,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"f31","extra":null},{"id":46,"type":"circle","mapType":"waypoint","x":1192,"y":332,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"f40","extra":null},{"id":47,"type":"circle","mapType":"waypoint","x":1196,"y":570,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"f32","extra":null},{"id":48,"type":"circle","mapType":"waypoint","x":1309,"y":265,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"g44","extra":null},{"id":49,"type":"circle","mapType":"waypoint","x":1307,"y":333,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"g40","extra":null},{"id":50,"type":"circle","mapType":"waypoint","x":1308,"y":400,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"g38","extra":null},{"id":51,"type":"circle","mapType":"waypoint","x":1360,"y":334,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"h37","extra":null},{"id":52,"type":"circle","mapType":"waypoint","x":1361,"y":552,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"h31","extra":null},{"id":53,"type":"circle","mapType":"waypoint","x":1357,"y":634,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"h29","extra":null},{"id":54,"type":"circle","mapType":"waypoint","x":1305,"y":636,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"g30","extra":null},{"id":55,"type":"circle","mapType":"waypoint","x":1303,"y":570,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"g32","extra":null},{"id":56,"type":"circle","mapType":"waypoint","x":1308,"y":492,"w":16,"h":16,"color":"#e74c3c","label":"","objectId":"g36","extra":null},{"id":59,"type":"rectangle","mapType":"wall","x":602.5480803527387,"y":340,"w":57.45191964726132,"h":10,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":60,"type":"rectangle","mapType":"wall","x":665.5370990141842,"y":375.44657696423286,"w":55.399980268500144,"h":10,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":61,"type":"rectangle","mapType":"wall","x":660.4932723174649,"y":570.7533638412676,"w":55.399980268500144,"h":10,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":62,"type":"rectangle","mapType":"wall","x":602.326176870129,"y":614.2793828593979,"w":57.89859526899352,"h":10,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":63,"type":"rectangle","mapType":"wall","x":743.2137908005678,"y":377.99178866045884,"w":55.399980268500144,"h":10,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":64,"type":"rectangle","mapType":"wall","x":742.7233871396157,"y":336.5205776776025,"w":55.399980268500144,"h":10,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":65,"type":"rectangle","mapType":"wall","x":799.1507714257529,"y":378.52878901714365,"w":55.399980268500144,"h":10,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":66,"type":"rectangle","mapType":"wall","x":799.8408848481478,"y":570.7999605370003,"w":55.399980268500144,"h":10,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":67,"type":"rectangle","mapType":"wall","x":878.613771069068,"y":379.0657893738284,"w":55.399980268500144,"h":10,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":68,"type":"rectangle","mapType":"wall","x":937.3178668730886,"y":379.33428955217084,"w":61.37801759139097,"h":10,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":69,"type":"rectangle","mapType":"wall","x":934.9479619637395,"y":333.3096555335474,"w":62.98901866144547,"h":10,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":70,"type":"rectangle","mapType":"wall","x":879.5479816952395,"y":520.7589038392945,"w":52.632865089664506,"h":10,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":71,"type":"rectangle","mapType":"wall","x":881.0657893738286,"y":569.5972497324864,"w":117.63009509065103,"h":10,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":73,"type":"rectangle","mapType":"wall","x":1018.4273842861372,"y":378.3534822302667,"w":51.873961250369916,"h":10,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":74,"type":"rectangle","mapType":"wall","x":1071.0602493758017,"y":336.88227124741036,"w":51.873961250369916,"h":10,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":75,"type":"rectangle","mapType":"wall","x":1069.0520380362605,"y":570.1342500891712,"w":51.873961250369916,"h":10,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":76,"type":"rectangle","mapType":"wall","x":1017.7150771425754,"y":524.1096160705478,"w":51.873961250369916,"h":10,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":77,"type":"rectangle","mapType":"wall","x":1281.008112682042,"y":378.6685791043418,"w":59.778096517390395,"h":10,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":78,"type":"rectangle","mapType":"wall","x":1278.7314011641586,"y":287.86861856734146,"w":63.08221205291079,"h":10,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":79,"type":"rectangle","mapType":"wall","x":1280.2492088427475,"y":612.189058124445,"w":122.18351812641822,"h":10,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":80,"type":"rectangle","mapType":"wall","x":1278.9999013425008,"y":523.1288087486435,"w":63.47942232239757,"h":10,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":81,"type":"rectangle","mapType":"wall","x":656.6332934487207,"y":241.69504882702986,"w":10,"h":197.3149982165759,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":82,"type":"rectangle","mapType":"wall","x":654.5906869007298,"y":478.40425627002134,"w":7.589038392945213,"h":202.37435714520606,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":83,"type":"rectangle","mapType":"wall","x":929.4825220229679,"y":238.9279336481942,"w":7.589038392945213,"h":202.37435714520606,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":84,"type":"rectangle","mapType":"wall","x":1060.9071363100913,"y":240.0085958508198,"w":10,"h":200.687904168996,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":86,"type":"rectangle","mapType":"wall","x":1064.7671151788356,"y":477.08615835287515,"w":7.589038392945213,"h":202.37435714520606,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":88,"type":"rectangle","mapType":"wall","x":1336.404762205914,"y":238.32214287460974,"w":10,"h":200.8188235135393,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":89,"type":"rectangle","mapType":"wall","x":1336.0486086341332,"y":481.17137144885703,"w":10,"h":199.7381613109137,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":90,"type":"rectangle","mapType":"wall","x":792.1553223191092,"y":240.0085958508198,"w":10,"h":199.00145119278596,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":91,"type":"rectangle","mapType":"wall","x":790.2314336283786,"y":478.16682055550075,"w":10,"h":205.14147232404173,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":93,"type":"rectangle","mapType":"wall","x":438.1189151722589,"y":203.74985686230372,"w":993.3208029877197,"h":16.02130327399547,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":94,"type":"rectangle","mapType":"wall","x":430.292441064793,"y":700.4102583561636,"w":1001.9905035832907,"h":16.62709404757993,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":95,"type":"rectangle","mapType":"wall","x":1422.1642267908235,"y":203.74985686230372,"w":14.334850297785351,"h":513.5249312559604,"color":"#2c3e50","label":"","objectId":"","extra":null},{"id":96,"type":"rectangle","mapType":"wall","x":425.23308213616315,"y":204.35564763588815,"w":14.334850297785351,"h":513.5249312559604,"color":"#2c3e50","label":"","objectId":"","extra":null}]}
           
           viewer.loadMapData(sampleData);
           extractCorridorsWallsAndWaypoints();
           updateInfo();
       };

       function extractCorridorsWallsAndWaypoints() {
           corridors = [];
           walls = [];
           waypoints = [];

           for (let i = 0; i < viewer.objects.getObjectCount(); i++) {
               const mapType = viewer.objects.mapTypes[i];
               const bounds = viewer.objects.getBounds(i);
               const objectId = viewer.objects.getObjectId(i);

               if (mapType === 'corridor') {
                   corridors.push({
                       id: objectId,
                       x: bounds.x,
                       y: bounds.y,
                       width: bounds.width,
                       height: bounds.height
                   });
               } else if (mapType === 'wall') {
                   walls.push({
                       id: objectId,
                       x: bounds.x,
                       y: bounds.y,
                       width: bounds.width,
                       height: bounds.height
                   });
               } else if (mapType === 'waypoint') {
                   waypoints.push({
                       id: objectId,
                       x: bounds.x + bounds.width / 2,
                       y: bounds.y + bounds.height / 2
                   });
               }
           }

           console.log(`Found ${corridors.length} corridors, ${walls.length} walls, ${waypoints.length} waypoints`);
           updateWaypointDropdowns();
       }

       function updateWaypointDropdowns() {
           const fromSelect = document.getElementById('from-waypoint');
           const toSelect = document.getElementById('to-waypoint');

           // Clear existing options except first
           fromSelect.innerHTML = '<option value="">Select waypoint...</option>';
           toSelect.innerHTML = '<option value="">Select waypoint...</option>';

           // Add waypoint options
           waypoints.forEach(waypoint => {
               const option1 = document.createElement('option');
               option1.value = waypoint.id;
               option1.textContent = waypoint.id || 'Unnamed';
               fromSelect.appendChild(option1);

               const option2 = document.createElement('option');
               option2.value = waypoint.id;
               option2.textContent = waypoint.id || 'Unnamed';
               toSelect.appendChild(option2);
           });
       }

       function findNearestCorridorPosition(waypoint) {
           if (corridors.length === 0) return waypoint;

           const pathfinder = new OrthogonalPathfinder(corridors, walls, gridSize, objectSize);
           let nearestPos = waypoint;
           let minDistance = Infinity;

           for (const corridor of corridors) {
               // ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏´‡∏•‡∏≤‡∏¢‡∏à‡∏∏‡∏î‡πÉ‡∏ô corridor
               const testPoints = [
                   // Center
                   { x: corridor.x + corridor.width / 2, y: corridor.y + corridor.height / 2 },
                   // Corners (‡∏´‡πà‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏Ç‡∏≠‡∏ö‡∏ô‡∏¥‡∏î‡∏´‡∏ô‡πà‡∏≠‡∏¢)
                   { x: corridor.x + 5, y: corridor.y + 5 },
                   { x: corridor.x + corridor.width - 5, y: corridor.y + 5 },
                   { x: corridor.x + 5, y: corridor.y + corridor.height - 5 },
                   { x: corridor.x + corridor.width - 5, y: corridor.y + corridor.height - 5 }
               ];

               for (const testPoint of testPoints) {
                   // ‡∏ï‡∏£‡∏ß‡∏à‡∏ß‡πà‡∏≤‡∏ß‡∏≤‡∏á object ‡πÑ‡∏î‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                   if (pathfinder.canPlaceObjectAt(testPoint.x, testPoint.y)) {
                       const distance = Math.sqrt(
                           Math.pow(waypoint.x - testPoint.x, 2) +
                           Math.pow(waypoint.y - testPoint.y, 2)
                       );

                       if (distance < minDistance) {
                           minDistance = distance;
                           nearestPos = testPoint;
                       }
                   }
               }
           }

           return nearestPos;
       }

       window.findPaths = function () {
            if (corridors.length === 0) {
                alert('Need corridors to find paths');
                return;
            }

            const fromWaypointId = document.getElementById('from-waypoint').value;
            const toWaypointId = document.getElementById('to-waypoint').value;

            if (!fromWaypointId || !toWaypointId) {
                alert('Please select both source and destination waypoints');
                return;
            }

            if (fromWaypointId === toWaypointId) {
                alert('Source and destination waypoints must be different');
                return;
            }

            console.log(`Finding path with object size: ${objectSize}`);

            // ‡∏•‡πâ‡∏≤‡∏á‡πÄ‡∏™‡πâ‡∏ô‡πÄ‡∏Å‡πà‡∏≤‡πÅ‡∏•‡∏∞ render canvas ‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡∏Å‡πà‡∏≠‡∏ô
            paths = [];
            viewer.render();

            const pathfinder = new OrthogonalPathfinder(corridors, walls, gridSize, objectSize);

            const fromWaypoint = waypoints.find(w => w.id === fromWaypointId);
            const toWaypoint = waypoints.find(w => w.id === toWaypointId);

            if (!fromWaypoint || !toWaypoint) {
                alert('Selected waypoints not found');
                return;
            }

            // Check if waypoints are in corridors, if not find nearest corridor positions
            const fromPos = pathfinder.canPlaceObjectAt(fromWaypoint.x, fromWaypoint.y)
                ? fromWaypoint
                : findNearestCorridorPosition(fromWaypoint);

            const toPos = pathfinder.canPlaceObjectAt(toWaypoint.x, toWaypoint.y)
                ? toWaypoint
                : findNearestCorridorPosition(toWaypoint);

            console.log('From position:', fromPos);
            console.log('To position:', toPos);

            const path = pathfinder.findPath(fromPos, toPos);
            if (path) {
                paths.push({
                    from: fromWaypointId,
                    to: toWaypointId,
                    points: path,
                    fromOriginal: fromWaypoint,
                    toOriginal: toWaypoint,
                    fromAdjusted: fromPos,
                    toAdjusted: toPos
                });

                console.log(`Found path from ${fromWaypointId} to ${toWaypointId}`);
            } else {
                alert(`No path found from ${fromWaypointId} to ${toWaypointId}`);
            }

            viewer.render();
        };

       function drawPaths() {
           if (corridors.length === 0) return;

           if (showDebug) {
               drawCorridorBuffers();
           }

           const corridorCache = createCorridorCache();
           const lineWidth = calculateLineWidth();

           paths.forEach((path, index) => {
               const hue = (index * 137.5) % 360;
               const color = `hsl(${hue}, 70%, 50%)`;
               drawPathWithCache(path.points, color, lineWidth, corridorCache);

               // Draw adjustment indicators if waypoints were moved
               if (path.fromOriginal && path.fromAdjusted) {
                   drawAdjustmentIndicator(path.fromOriginal, path.fromAdjusted, color);
               }
               if (path.toOriginal && path.toAdjusted) {
                   drawAdjustmentIndicator(path.toOriginal, path.toAdjusted, color);
               }
           });
       }

       function drawAdjustmentIndicator(original, adjusted, color) {
            const ctx = viewer.ctx;
            const distance = Math.sqrt(
                Math.pow(original.x - adjusted.x, 2) +
                Math.pow(original.y - adjusted.y, 2)
            );

            // Only draw if positions are different
            if (distance > 1) {
                ctx.save();
                ctx.scale(viewer.zoom, viewer.zoom);
                ctx.translate(viewer.panX / viewer.zoom, viewer.panY / viewer.zoom);

                // Draw orthogonal line (L-shaped) from original to adjusted position
                // BUT avoid drawing through walls
                ctx.strokeStyle = color;
                ctx.lineWidth = 2 / viewer.zoom;
                ctx.setLineDash([5 / viewer.zoom, 5 / viewer.zoom]);
                
                const deltaX = Math.abs(adjusted.x - original.x);
                const deltaY = Math.abs(adjusted.y - original.y);

                if (deltaX > deltaY) {
                    // Go horizontal first, then vertical
                    const midPoint = { x: adjusted.x, y: original.y };
                    
                    // Draw first segment only if it doesn't intersect walls
                    if (!lineIntersectsWalls(original, midPoint)) {
                        ctx.beginPath();
                        ctx.moveTo(original.x, original.y);
                        ctx.lineTo(adjusted.x, original.y);
                        ctx.stroke();
                    }
                    
                    // Draw second segment only if it doesn't intersect walls
                    if (!lineIntersectsWalls(midPoint, adjusted)) {
                        ctx.beginPath();
                        ctx.moveTo(adjusted.x, original.y);
                        ctx.lineTo(adjusted.x, adjusted.y);
                        ctx.stroke();
                    }
                } else {
                    // Go vertical first, then horizontal
                    const midPoint = { x: original.x, y: adjusted.y };
                    
                    // Draw first segment only if it doesn't intersect walls
                    if (!lineIntersectsWalls(original, midPoint)) {
                        ctx.beginPath();
                        ctx.moveTo(original.x, original.y);
                        ctx.lineTo(original.x, adjusted.y);
                        ctx.stroke();
                    }
                    
                    // Draw second segment only if it doesn't intersect walls
                    if (!lineIntersectsWalls(midPoint, adjusted)) {
                        ctx.beginPath();
                        ctx.moveTo(original.x, adjusted.y);
                        ctx.lineTo(adjusted.x, adjusted.y);
                        ctx.stroke();
                    }
                }

                ctx.setLineDash([]);

                // Draw small circle at adjusted position
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(adjusted.x, adjusted.y, 4 / viewer.zoom, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

       function drawCorridorBuffers() {
            const ctx = viewer.ctx;
            const halfSize = objectSize / 2;

            ctx.save();
            ctx.scale(viewer.zoom, viewer.zoom);
            ctx.translate(viewer.panX / viewer.zoom, viewer.panY / viewer.zoom);

            // Draw corridor areas (yellow) - only if enabled
            if (showCorridors) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.2)';
                corridors.forEach(corridor => {
                    ctx.fillRect(corridor.x, corridor.y, corridor.width, corridor.height);
                });
            }

            // Draw wall areas (red) - only if enabled
            if (showWalls) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                walls.forEach(wall => {
                    ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
                });
            }

            // Draw safe walkable areas in corridors (green) - only if corridors are shown
            if (showCorridors) {
                ctx.fillStyle = 'rgba(0, 255, 0, 0.4)';
                ctx.beginPath();
                corridors.forEach(corridor => {
                    const safeLeft = corridor.x + halfSize;
                    const safeTop = corridor.y + halfSize;
                    const safeWidth = corridor.width - objectSize;
                    const safeHeight = corridor.height - objectSize;

                    if (safeWidth > 0 && safeHeight > 0) {
                        ctx.rect(safeLeft, safeTop, safeWidth, safeHeight);
                    }
                });
                ctx.fill();
            }

            // Draw walkable grid points (blue dots) - only if corridors are shown
            if (showCorridors) {
                const pathfinder = new OrthogonalPathfinder(corridors, walls, gridSize, objectSize);
                ctx.fillStyle = 'rgba(0, 0, 255, 1)';

                let walkableCount = 0;
                for (let y = 0; y < pathfinder.rows; y++) {
                    for (let x = 0; x < pathfinder.cols; x++) {
                        if (pathfinder.grid[y][x].walkable) {
                            walkableCount++;
                            const worldX = pathfinder.grid[y][x].worldX;
                            const worldY = pathfinder.grid[y][x].worldY;
                            ctx.beginPath();
                            ctx.arc(worldX, worldY, 2 / viewer.zoom, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
                console.log(`Object ${objectSize}px: ${walkableCount} valid positions`);
            }

            // Draw waypoint validity indicators - only if waypoints are shown
            if (showWaypoints) {
                const pathfinder = new OrthogonalPathfinder(corridors, walls, gridSize, objectSize);
                ctx.fillStyle = 'rgba(255, 100, 100, 0.6)';
                ctx.strokeStyle = 'rgba(255, 0, 0, 1)';
                ctx.lineWidth = 1 / viewer.zoom;

                waypoints.forEach(waypoint => {
                    const canPlace = pathfinder.canPlaceObjectAt(waypoint.x, waypoint.y);

                    if (canPlace) {
                        ctx.fillStyle = 'rgba(100, 255, 100, 0.6)';
                        ctx.strokeStyle = 'rgba(0, 255, 0, 1)';
                    } else {
                        ctx.fillStyle = 'rgba(255, 100, 100, 0.8)';
                        ctx.strokeStyle = 'rgba(255, 0, 0, 1)';
                    }

                    // Draw object size representation at waypoint
                    ctx.fillRect(waypoint.x - halfSize, waypoint.y - halfSize, objectSize, objectSize);
                    ctx.strokeRect(waypoint.x - halfSize, waypoint.y - halfSize, objectSize, objectSize);

                    // Draw X if waypoint is invalid
                    if (!canPlace) {
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 3 / viewer.zoom;
                        ctx.beginPath();
                        ctx.moveTo(waypoint.x - halfSize + 2, waypoint.y - halfSize + 2);
                        ctx.lineTo(waypoint.x + halfSize - 2, waypoint.y + halfSize - 2);
                        ctx.moveTo(waypoint.x + halfSize - 2, waypoint.y - halfSize + 2);
                        ctx.lineTo(waypoint.x - halfSize + 2, waypoint.y + halfSize - 2);
                        ctx.stroke();
                    }

                    // Draw waypoint center point
                    ctx.fillStyle = 'rgba(255, 0, 0, 1)';
                    ctx.beginPath();
                    ctx.arc(waypoint.x, waypoint.y, 3 / viewer.zoom, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw waypoint label
                    ctx.fillStyle = 'black';
                    ctx.font = `${12 / viewer.zoom}px Arial`;
                    ctx.fillText(waypoint.id + (canPlace ? '' : ' ‚úó'), waypoint.x + halfSize + 5, waypoint.y - halfSize - 5);
                });
            }

            if (viewer.getVisibility('corridors')) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.2)';
                corridors.forEach(corridor => {
                    ctx.fillRect(corridor.x, corridor.y, corridor.width, corridor.height);
                });
            }

            if (viewer.getVisibility('walls')) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                walls.forEach(wall => {
                    ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
                });
            }

            ctx.restore();
        }

       window.toggleDebug = function () {
        showDebug = !showDebug;

           viewer.render(); 
       };

       function createCorridorCache() {
            const canvas = document.createElement('canvas');
            const bounds = getMapBounds();

            const padding = 50;
            canvas.width = bounds.width + padding * 2;
            canvas.height = bounds.height + padding * 2;
            const ctx = canvas.getContext('2d');

            bounds.minX -= padding;
            bounds.minY -= padding;
            bounds.width += padding * 2;
            bounds.height += padding * 2;

            // ‡∏ß‡∏≤‡∏î corridors ‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏µ‡∏Ç‡∏≤‡∏ß (‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏ß‡∏≤‡∏î‡πÄ‡∏™‡πâ‡∏ô‡πÑ‡∏î‡πâ)
            ctx.fillStyle = '#ffffff';
            corridors.forEach(corridor => {
                const x = corridor.x - bounds.minX;
                const y = corridor.y - bounds.minY;
                ctx.fillRect(x, y, corridor.width, corridor.height);
            });

            // ‡∏ß‡∏≤‡∏î walls ‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏µ‡∏î‡∏≥ (‡∏ö‡∏•‡πá‡∏≠‡∏Å‡πÄ‡∏™‡πâ‡∏ô) ‡∏ó‡∏±‡∏ö‡∏•‡∏á‡πÑ‡∏õ‡∏ö‡∏ô corridors
            ctx.fillStyle = '#000000';
            walls.forEach(wall => {
                const x = wall.x - bounds.minX;
                const y = wall.y - bounds.minY;
                ctx.fillRect(x, y, wall.width, wall.height);
            });

            return { canvas, bounds };
        }

       function getMapBounds() {
           let minX = Infinity, minY = Infinity;
           let maxX = -Infinity, maxY = -Infinity;

           // Include both corridors and walls in bounds calculation
           [...corridors, ...walls].forEach(obj => {
               minX = Math.min(minX, obj.x);
               minY = Math.min(minY, obj.y);
               maxX = Math.max(maxX, obj.x + obj.width);
               maxY = Math.max(maxY, obj.y + obj.height);
           });

           return {
               minX: minX,
               minY: minY,
               width: maxX - minX,
               height: maxY - minY
           };
       }

       function drawPathWithCache(points, color, lineWidth, corridorCache) {
            if (points.length < 2) return;

            const ctx = viewer.ctx;
            const { canvas: cacheCanvas, bounds } = corridorCache;

            ctx.save();

            const pathCanvas = document.createElement('canvas');
            pathCanvas.width = cacheCanvas.width;
            pathCanvas.height = cacheCanvas.height;
            const pathCtx = pathCanvas.getContext('2d');

            pathCtx.strokeStyle = '#ffffff';
            pathCtx.lineWidth = lineWidth;
            pathCtx.lineCap = 'round';
            pathCtx.lineJoin = 'round';

            // ‡∏ß‡∏≤‡∏î‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏ö‡∏ö segment by segment ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö walls
            pathCtx.beginPath();
            pathCtx.moveTo(points[0].x - bounds.minX, points[0].y - bounds.minY);

            for (let i = 1; i < points.length; i++) {
                const prevPoint = points[i - 1];
                const currentPoint = points[i];
                
                // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á 2 ‡∏à‡∏∏‡∏î‡∏ô‡∏µ‡πâ‡∏ú‡πà‡∏≤‡∏ô wall ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                if (!lineIntersectsWalls(prevPoint, currentPoint)) {
                    pathCtx.lineTo(currentPoint.x - bounds.minX, currentPoint.y - bounds.minY);
                } else {
                    // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ú‡πà‡∏≤‡∏ô wall ‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡∏ß‡∏≤‡∏î‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ
                    pathCtx.moveTo(currentPoint.x - bounds.minX, currentPoint.y - bounds.minY);
                }
            }

            pathCtx.stroke();

            // ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°...
            const resultCanvas = document.createElement('canvas');
            resultCanvas.width = cacheCanvas.width;
            resultCanvas.height = cacheCanvas.height;
            const resultCtx = resultCanvas.getContext('2d');

            resultCtx.drawImage(pathCanvas, 0, 0);
            resultCtx.globalCompositeOperation = 'source-in';
            resultCtx.drawImage(cacheCanvas, 0, 0);
            resultCtx.globalCompositeOperation = 'source-atop';
            resultCtx.fillStyle = color;
            resultCtx.fillRect(0, 0, resultCanvas.width, resultCanvas.height);

            ctx.scale(viewer.zoom, viewer.zoom);
            ctx.translate(viewer.panX / viewer.zoom, viewer.panY / viewer.zoom);

            ctx.globalCompositeOperation = 'source-over';
            ctx.drawImage(resultCanvas, bounds.minX, bounds.minY);

            ctx.fillStyle = color;
            const markerSize = lineWidth / viewer.zoom / 2;
            ctx.fillRect(points[0].x - markerSize, points[0].y - markerSize, markerSize * 2, markerSize * 2);
            ctx.fillRect(points[points.length - 1].x - markerSize, points[points.length - 1].y - markerSize, markerSize * 2, markerSize * 2);

            ctx.restore();
        }

        function lineIntersectsWalls(point1, point2) {
            // ‡∏™‡∏∏‡πà‡∏°‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏à‡∏∏‡∏î‡∏´‡∏•‡∏≤‡∏¢‡πÜ ‡∏à‡∏∏‡∏î‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á point1 ‡πÅ‡∏•‡∏∞ point2
            const samples = 20; // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
            
            for (let i = 0; i <= samples; i++) {
                const t = i / samples;
                const checkX = point1.x + (point2.x - point1.x) * t;
                const checkY = point1.y + (point2.y - point1.y) * t;
                
                // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏à‡∏∏‡∏î‡∏ô‡∏µ‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô wall ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                for (const wall of walls) {
                    if (checkX >= wall.x && checkX <= wall.x + wall.width &&
                        checkY >= wall.y && checkY <= wall.y + wall.height) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        function lineIntersectsRect(point1, point2, rect) {
            const x1 = point1.x, y1 = point1.y;
            const x2 = point2.x, y2 = point2.y;
            const left = rect.x, top = rect.y;
            const right = rect.x + rect.width, bottom = rect.y + rect.height;

            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡∏à‡∏∏‡∏î‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô wall
            if ((x1 >= left && x1 <= right && y1 >= top && y1 <= bottom) ||
                (x2 >= left && x2 <= right && y2 >= top && y2 <= bottom)) {
                return true;
            }

            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏Å‡∏±‡∏ô‡∏Å‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ç‡∏≠‡∏ö‡∏Ç‡∏≠‡∏á wall
            if (lineIntersectsLine(x1, y1, x2, y2, left, top, right, top) ||    // top edge
                lineIntersectsLine(x1, y1, x2, y2, right, top, right, bottom) || // right edge
                lineIntersectsLine(x1, y1, x2, y2, right, bottom, left, bottom) || // bottom edge
                lineIntersectsLine(x1, y1, x2, y2, left, bottom, left, top)) {   // left edge
                return true;
            }

            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°: ‡πÄ‡∏™‡πâ‡∏ô‡∏ú‡πà‡∏≤‡∏ô wall ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏ï‡∏±‡∏î‡∏Ç‡∏≠‡∏ö (‡πÄ‡∏™‡πâ‡∏ô‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô/‡∏ï‡∏±‡πâ‡∏á‡∏ú‡πà‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á wall)
            if ((x1 < left && x2 > right && y1 >= top && y1 <= bottom && y2 >= top && y2 <= bottom) ||
                (y1 < top && y2 > bottom && x1 >= left && x1 <= right && x2 >= left && x2 <= right)) {
                return true;
            }

            return false;
        }

        function lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏Å‡∏±‡∏ô‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏™‡πâ‡∏ô 2 ‡πÄ‡∏™‡πâ‡∏ô
            const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (Math.abs(denom) < 1e-10) return false; // parallel lines

            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;

            return t >= 0 && t <= 1 && u >= 0 && u <= 1;
        }

      function redrawPaths() {
           viewer.render(); // Simplified - render handles everything
           updateInfo();
       }

       window.clearPaths = function () {
           paths = [];
           showDebug = false;
           document.getElementById('from-waypoint').value = '';
           document.getElementById('to-waypoint').value = '';
           viewer.render();
           updateInfo();
       };

       setInterval(() => {
           if (viewer) {
               const zoom = Math.round(viewer.zoom * 100);
               const currentZoom = document.getElementById('zoom-level').textContent;
               if (currentZoom !== zoom + '%') {
                   updateInfo();
               }
           }
       }, 100);
   </script>
</body>

</html>