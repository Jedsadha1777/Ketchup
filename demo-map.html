<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orthogonal Pathfinding Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            overflow: hidden;
        }

        .container {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: #1e1e1e;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 8px;
            z-index: 100;
        }

        .controls button {
            background: #0066cc;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            margin: 3px;
            cursor: pointer;
            font-size: 11px;
        }

        .controls button:hover {
            background: #0088ff;
        }

        .controls input[type="file"] {
            margin: 10px 0;
            padding: 8px;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 100%;
        }

        #runtime-canvas {
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            z-index: 1 !important;
            background: #f8f9fa !important;
        }

        .info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
        }

        /* Context Menu Styles */
        .context-menu {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            min-width: 120px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            display: none;
        }

        .context-menu-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }

        .context-menu-item:last-child {
            border-bottom: none;
        }

        .context-menu-item:hover {
            background-color: #f0f0f0;
        }
    </style>
</head>

<body>
    <div class="container">
        <canvas id="runtime-canvas"></canvas>

        <!-- Context Menu -->
        <div id="context-menu" class="context-menu">
            <div class="context-menu-item" onclick="setFromHere()">From here</div>
            <div class="context-menu-item" onclick="setToHere()">To here</div>
            <div class="context-menu-item" onclick="clearSelection()">Clear selection</div>
        </div>


        <div class="controls">
            <h3>Orthogonal Pathfinding</h3>
            <input type="file" id="file-input" accept=".json">
            <button onclick="loadFile()">Load JSON</button>

            <div style="margin: 10px 0;">
                <label style="color: white; display: block; margin-bottom: 4px;">From Waypoint:</label>
                <select id="from-waypoint" style="width: 100%; padding: 4px;">
                    <option value="">Select waypoint...</option>
                </select>
            </div>

            <div style="margin: 10px 0;">
                <label style="color: white; display: block; margin-bottom: 4px;">To Waypoint:</label>
                <select id="to-waypoint" style="width: 100%; padding: 4px;">
                    <option value="">Select waypoint...</option>
                </select>
            </div>

            <button onclick="findPaths()">Find Path</button>
            <button onclick="clearPaths()">Clear</button>
            <button onclick="toggleDebug()">Debug</button>
            <button onclick="loadSample()">Sample</button>

            <div style="margin: 10px 0; padding-top: 10px; border-top: 1px solid #555;">
                <div style="color: #aaa; font-size: 10px;">
                    Left-click & drag to pan, Right-click for menu

                </div>
            </div>

            <!-- Toggle visibility controls -->
            <!-- <div style="margin: 10px 0; border-top: 1px solid #555; padding-top: 10px;"> -->
            <label style="color: white; display: block; margin-bottom: 8px; font-size: 12px;">Visibility:</label>
            <div style="display: flex; flex-wrap: wrap; gap: 5px;">
                <label style="color: white; font-size: 11px; display: flex; align-items: center;">
                    <input type="checkbox" id="show-corridors" checked style="margin-right: 4px;">
                    Corridors
                </label>
                <label style="color: white; font-size: 11px; display: flex; align-items: center;">
                    <input type="checkbox" id="show-walls" checked style="margin-right: 4px;">
                    Walls
                </label>
                <label style="color: white; font-size: 11px; display: flex; align-items: center;">
                    <input type="checkbox" id="show-waypoints" checked style="margin-right: 4px;">
                    Waypoints
                </label>
                <label style="color: white; font-size: 11px; display: flex; align-items: center;">
                    <input type="checkbox" id="show-images" checked style="margin-right: 4px;">
                    Images
                </label>
                <label style="color: white; font-size: 11px; display: flex; align-items: center;">
                    <input type="checkbox" id="show-warppoints" checked style="margin-right: 4px;">
                    Warppoints
                </label>

            </div>
            <!-- </div> -->

            <div style="margin-top: 10px;">
                <label style="display: block; color: white; margin-bottom: 4px;">Object Size:</label>
                <input type="range" id="object-size" min="1" max="40" value="5" style="width: 100%;">
                <span id="size-value" style="color: white; font-size: 10px;">5px</span>
            </div>
        </div>

        <div class="info">
            <div>Corridors: <span id="corridor-count">0</span></div>
            <div>Walls: <span id="wall-count">0</span></div>
            <div>Waypoints: <span id="waypoint-count">0</span></div>
            <div>Paths: <span id="path-count">0</span></div>
            <div>Object Size: <span id="current-size">5</span>px</div>
            <div>Min Corridor: <span id="min-corridor">0</span>px</div>
            <div>Zoom: <span id="zoom-level">100%</span></div>
        </div>
    </div>

    <script type="module">
        import { RuntimeViewer } from './runtime/RuntimeViewer.js';
        import { OrthogonalPathfinder, lineIntersectsWalls } from './demo-map/pathfinder.js';
        import { findNearestCorridorPosition, findPortalPath, createStraightLinePath } from './demo-map/pathfinding-utils.js';

        // =============================================================================
        // GLOBAL VARIABLES
        // =============================================================================
        let viewer = null;
        let corridors = [];
        let walls = [];
        let waypoints = [];
        let paths = [];
        let gridSize = 5;
        let objectSize = 5;
        let showDebug = false;
        let showCorridors = true;
        let showWalls = true;
        let showWaypoints = true;
        let showWarppoints = true;

        let isPanning = false;
        let lastPanX = 0;
        let lastPanY = 0;

        // Context menu state
        let contextMenuVisible = false;
        let contextMenuX = 0;
        let contextMenuY = 0;

        // =============================================================================
        // INITIALIZATION
        // =============================================================================
        document.addEventListener('DOMContentLoaded', () => {
            initViewer();
            setupEventHandlers();
            setupContextMenu();
            updateInfo();
        });

        function initViewer() {
            const canvas = document.getElementById('runtime-canvas');
            viewer = new RuntimeViewer(canvas, {
                showGrid: false,
                enableEvents: true,
                enableInteraction: true
            });

            // เก็บ visibility checkbox 
            viewer.visibilityState = {
                corridors: true,
                walls: true,
                waypoints: true,
                images: true,
                warppoints: true

            };

            viewer.setVisibility = function (type, visible) {

                this.visibilityState[type] = visible;

                const objects = this.objects;
                for (let i = 0; i < objects.getObjectCount(); i++) {
                    const mapType = objects.mapTypes[i];
                    const objType = objects.types[i];

                    let shouldHide = false;
                    if (mapType === 'corridor' && !this.visibilityState.corridors) shouldHide = true;
                    if (mapType === 'wall' && !this.visibilityState.walls) shouldHide = true;
                    if (mapType === 'waypoint' && !this.visibilityState.waypoints) shouldHide = true;
                    if (mapType === 'warppoint' && !this.visibilityState.warppoints) shouldHide = true;
                    if ((objType === 'image' || objType === 'text') && !this.visibilityState.images) shouldHide = true;

                    // ซ่อนโดยการย้ายออกนอกหน้าจอ
                    if (shouldHide) {
                        if (!objects.originalPositions) objects.originalPositions = {};
                        if (!objects.originalPositions[i]) {
                            objects.originalPositions[i] = {
                                x: objects.x[i],
                                y: objects.y[i]
                            };
                        }
                        objects.x[i] = -99999;
                        objects.y[i] = -99999;
                    } else {
                        // คืนตำแหน่งเดิม
                        if (objects.originalPositions && objects.originalPositions[i]) {
                            objects.x[i] = objects.originalPositions[i].x;
                            objects.y[i] = objects.originalPositions[i].y;
                        }
                    }
                }
                this.render();
            };

            const originalRender = viewer.render.bind(viewer);
            viewer.render = function () {
                originalRender();
                drawWarppoints();
                if (showDebug) drawCorridorBuffers();  // ย้ายมาก่อน
    if (paths.length > 0) drawPaths();      //

                drawTempWaypoints();
                drawWaypointLabels(); //label บน waypoint อาจจะย้ายออกไปใส่แค่ debug ทีหลัง
            };

            window.viewer = viewer;
        }

        function setupEventHandlers() {
            const canvas = document.getElementById('runtime-canvas');

            canvas.addEventListener('wheel', (e) => {

                e.preventDefault();
                e.stopPropagation();

                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoom = Math.max(0.8, Math.min(5, viewer.zoom * zoomFactor));

                viewer.panX += (mouseX - viewer.panX) * (1 - newZoom / viewer.zoom);
                viewer.panY += (mouseY - viewer.panY) * (1 - newZoom / viewer.zoom);
                viewer.zoom = newZoom;

                viewer.render();
                updateInfo();
            });


            canvas.addEventListener('mousedown', handlePanStart);
            canvas.addEventListener('mousemove', handlePanMove);
            canvas.addEventListener('mouseup', handlePanEnd);
            canvas.addEventListener('mouseleave', handlePanEnd);
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());

            const sizeSlider = document.getElementById('object-size');
            const sizeValue = document.getElementById('size-value');
            sizeSlider.addEventListener('input', () => {
                objectSize = parseInt(sizeSlider.value);
                sizeValue.textContent = objectSize + 'px';
                updateInfo();
                if (paths.length > 0) findPaths();
            });

            const redrawHandler = () => {
                viewer.render();
                updateInfo();
            };

            // initial visibility state
            showCorridors = document.getElementById('show-corridors').checked;
            showWalls = document.getElementById('show-walls').checked;
            showWaypoints = document.getElementById('show-waypoints').checked;
            showWarppoints = document.getElementById('show-warppoints').checked;

            let showImages = document.getElementById('show-images').checked;

            document.getElementById('show-corridors').addEventListener('change', (e) => {
                showCorridors = e.target.checked;
                viewer.setVisibility('corridors', showCorridors);
                redrawHandler();
            });

            document.getElementById('show-walls').addEventListener('change', (e) => {
                showWalls = e.target.checked;
                viewer.setVisibility('walls', showWalls);
                redrawHandler();
            });

            document.getElementById('show-waypoints').addEventListener('change', (e) => {
                showWaypoints = e.target.checked;
                viewer.setVisibility('waypoints', showWaypoints);
                redrawHandler();
            });

            document.getElementById('show-images').addEventListener('change', (e) => {
                showImages = e.target.checked;
                viewer.setVisibility('images', showImages);
                redrawHandler();
            });

            document.getElementById('show-warppoints').addEventListener('change', (e) => {
                showWarppoints = e.target.checked;
                viewer.setVisibility('warppoints', showWarppoints);
                redrawHandler();
            });

            document.getElementById('from-waypoint').addEventListener('change', (e) => {
                const selectedValue = e.target.value;

                if (selectedValue) {
                    // Clear paths when changing waypoint
                    paths = [];

                    if (selectedValue.startsWith('temp_from_')) {
                        // Temp waypoint already has coordinates stored
                    } else {
                        // Regular waypoint - find coordinates and create temp marker
                        const waypoint = waypoints.find(w => w.id === selectedValue);
                        if (waypoint) {
                            window.tempFromPoint = { x: waypoint.x, y: waypoint.y };
                        }
                    }
                } else {
                    // Clear FROM marker when dropdown is empty
                    window.tempFromPoint = null;
                }

                viewer.render();
                updateInfo();
            });

            document.getElementById('to-waypoint').addEventListener('change', (e) => {
                const selectedValue = e.target.value;

                if (selectedValue) {
                    // Clear paths when changing waypoint
                    paths = [];

                    if (selectedValue.startsWith('temp_to_')) {
                        // Temp waypoint already has coordinates stored
                    } else {
                        // Regular waypoint - find coordinates and create temp marker
                        const waypoint = waypoints.find(w => w.id === selectedValue);
                        if (waypoint) {
                            window.tempToPoint = { x: waypoint.x, y: waypoint.y };
                        }
                    }
                } else {
                    // Clear TO marker when dropdown is empty
                    window.tempToPoint = null;
                }

                viewer.render();
                updateInfo();
            });


        }


        // =============================================================================
        // CONTEXT MENU HANDLING
        // =============================================================================
        function setupContextMenu() {
            const canvas = document.getElementById('runtime-canvas');
            const contextMenu = document.getElementById('context-menu');

            // Show context menu on right click
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();

                // Store world coordinates for menu actions
                const rect = e.target.getBoundingClientRect();
                contextMenuX = (e.clientX - rect.left - viewer.panX) / viewer.zoom;
                contextMenuY = (e.clientY - rect.top - viewer.panY) / viewer.zoom;

                // Show menu at mouse position
                contextMenu.style.left = e.clientX + 'px';
                contextMenu.style.top = e.clientY + 'px';
                contextMenu.style.display = 'block';
                contextMenuVisible = true;
            });

            // Hide context menu on click elsewhere
            document.addEventListener('click', (e) => {
                if (contextMenuVisible && !contextMenu.contains(e.target)) {
                    hideContextMenu();
                }
            });

            // Hide context menu on escape
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && contextMenuVisible) {
                    hideContextMenu();
                }
            });
        }

        function hideContextMenu() {
            const contextMenu = document.getElementById('context-menu');
            contextMenu.style.display = 'none';
            contextMenuVisible = false;
        }

        // Context menu actions
        window.setFromHere = function () {
            // Clear existing paths and TO point
            paths = [];
            // window.tempToPoint = null;
            // document.getElementById('to-waypoint').value = '';
            // removeTemporaryOptions('temp_to_');

            const fromSelect = document.getElementById('from-waypoint');
            const tempFromId = `temp_from_${Date.now()}`;

            // Remove existing temp from options
            removeTemporaryOptions('temp_from_');

            // Add new temp option
            const option = document.createElement('option');
            option.value = tempFromId;
            option.textContent = `From here (${contextMenuX.toFixed(1)}, ${contextMenuY.toFixed(1)})`;
            fromSelect.appendChild(option);
            fromSelect.value = tempFromId;

            // Store coordinates
            window.tempFromPoint = { x: contextMenuX, y: contextMenuY };

            console.log(`Set FROM point: (${contextMenuX.toFixed(1)}, ${contextMenuY.toFixed(1)})`);
            hideContextMenu();
            viewer.render();
            updateInfo();
        };

        window.setToHere = function () {
            // Clear existing paths
            paths = [];

            const toSelect = document.getElementById('to-waypoint');
            const tempToId = `temp_to_${Date.now()}`;

            // Remove existing temp to options
            removeTemporaryOptions('temp_to_');

            // Add new temp option
            const option = document.createElement('option');
            option.value = tempToId;
            option.textContent = `To here (${contextMenuX.toFixed(1)}, ${contextMenuY.toFixed(1)})`;
            toSelect.appendChild(option);
            toSelect.value = tempToId;

            // Store coordinates
            window.tempToPoint = { x: contextMenuX, y: contextMenuY };

            console.log(`Set TO point: (${contextMenuX.toFixed(1)}, ${contextMenuY.toFixed(1)})`);
            hideContextMenu();
            viewer.render();
            updateInfo();
        };

        window.clearSelection = function () {
            // Clear both dropdowns
            document.getElementById('from-waypoint').value = '';
            document.getElementById('to-waypoint').value = '';

            // Remove temp options
            removeTemporaryOptions('temp_from_');
            removeTemporaryOptions('temp_to_');

            // Clear temp points
            window.tempFromPoint = null;
            window.tempToPoint = null;

            // Clear paths
            paths = [];
            viewer.render();
            updateInfo();

            console.log('Cleared selection');
            hideContextMenu();
        };

        function removeTemporaryOptions(prefix) {
            ['from-waypoint', 'to-waypoint'].forEach(selectId => {
                const select = document.getElementById(selectId);
                const optionsToRemove = Array.from(select.options).filter(opt =>
                    opt.value.startsWith(prefix)
                );

                optionsToRemove.forEach(option => {
                    select.removeChild(option);
                });
            });
        }

        // =============================================================================
        // TEMP WAYPOINT RENDERING
        // =============================================================================
        function drawTempWaypoints() {
            const ctx = viewer.ctx;

            ctx.save();
            ctx.scale(viewer.zoom, viewer.zoom);
            ctx.translate(viewer.panX / viewer.zoom, viewer.panY / viewer.zoom);

            // Draw FROM point
            if (window.tempFromPoint) {
                const point = window.tempFromPoint;

                // Green circle for FROM
                ctx.fillStyle = '#22c55e';
                ctx.strokeStyle = '#16a34a';
                ctx.lineWidth = 2 / viewer.zoom;

                ctx.beginPath();
                ctx.arc(point.x, point.y, 8 / viewer.zoom, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // White "F" text
                ctx.fillStyle = 'white';
                ctx.font = `bold ${10 / viewer.zoom}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('F', point.x, point.y);

                // Label
                ctx.fillStyle = '#16a34a';
                ctx.font = `${11 / viewer.zoom}px Arial`;
                ctx.textAlign = 'left';
                ctx.fillText('FROM', point.x + 12 / viewer.zoom, point.y - 12 / viewer.zoom);
            }

            // Draw TO point
            if (window.tempToPoint) {
                const point = window.tempToPoint;

                // Red circle for TO
                ctx.fillStyle = '#ef4444';
                ctx.strokeStyle = '#dc2626';
                ctx.lineWidth = 2 / viewer.zoom;

                ctx.beginPath();
                ctx.arc(point.x, point.y, 8 / viewer.zoom, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // White "T" text
                ctx.fillStyle = 'white';
                ctx.font = `bold ${10 / viewer.zoom}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('T', point.x, point.y);

                // Label
                ctx.fillStyle = '#dc2626';
                ctx.font = `${11 / viewer.zoom}px Arial`;
                ctx.textAlign = 'left';
                ctx.fillText('TO', point.x + 12 / viewer.zoom, point.y - 12 / viewer.zoom);
            }

            ctx.restore();
        }

        // =============================================================================
        // WARPPOINT RENDERING
        // =============================================================================
        function drawWarppoints() {
            if (!showWarppoints) return;

            const ctx = viewer.ctx;
            ctx.save();
            ctx.scale(viewer.zoom, viewer.zoom);
            ctx.translate(viewer.panX / viewer.zoom, viewer.panY / viewer.zoom);

            waypoints.forEach(waypoint => {
                if (waypoint.type !== 'warppoint') return;

                const radius = 8;  // ใช้ radius เหมือนใน MAP_OBJECT_STYLES.warppoint

                ctx.fillStyle = '#9333ea';  // MAP_OBJECT_STYLES.warppoint.color
                ctx.strokeStyle = '#7e22ce';  // MAP_OBJECT_STYLES.warppoint.strokeColor
                ctx.lineWidth = 2 / viewer.zoom;

                ctx.beginPath();
                ctx.arc(waypoint.x, waypoint.y, radius, 0, Math.PI * 2);

                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(waypoint.x, waypoint.y, radius * 0.5, 0, Math.PI * 2);

                ctx.fill();
            });

            ctx.restore();
        }

        function drawWaypointLabels() {
            const ctx = viewer.ctx;

            ctx.save();
            ctx.scale(viewer.zoom, viewer.zoom);
            ctx.translate(viewer.panX / viewer.zoom, viewer.panY / viewer.zoom);

            waypoints.forEach(waypoint => {
                // Skip if hidden by visibility settings
                if (waypoint.type === 'warppoint' && !showWarppoints) return;
                if (waypoint.type === 'waypoint' && !showWaypoints) return;

                ctx.fillStyle = 'black';
                ctx.font = `${12 / viewer.zoom}px Arial`;

                let displayText = '';
                if (waypoint.type === 'warppoint' && waypoint.portalId) {
                    displayText = waypoint.label ?
                        `${waypoint.label}` : `${waypoint.portalId}`;
                } else if (waypoint.label) {
                    displayText = waypoint.label;
                } else {
                    displayText = waypoint.id;
                }

                if (displayText) {
                    ctx.fillText(displayText, waypoint.x + 10 / viewer.zoom, waypoint.y - 10 / viewer.zoom);
                }
            });

            ctx.restore();
        }


        // =============================================================================
        // PAN HANDLING
        // =============================================================================
        function handlePanStart(e) {
            if (e.button === 0) { // Left-click only
                e.preventDefault();
                e.stopPropagation();
                isPanning = true;
                lastPanX = e.clientX;
                lastPanY = e.clientY;
                const canvas = document.getElementById('runtime-canvas');
                canvas.style.cursor = 'grabbing';

            }

        }

        function handlePanMove(e) {
            if (!isPanning) {
                const canvas = document.getElementById('runtime-canvas');
                canvas.style.cursor = 'grab';


                return;
            }

            e.preventDefault();
            e.stopPropagation();

            const deltaX = e.clientX - lastPanX;
            const deltaY = e.clientY - lastPanY;

            viewer.panX += deltaX;
            viewer.panY += deltaY;
            lastPanX = e.clientX;
            lastPanY = e.clientY;
            viewer.render();
        }

        function handlePanEnd(e) {
            if (isPanning) {
                e.preventDefault();
                isPanning = false;
                const canvas = document.getElementById('runtime-canvas');
                canvas.style.cursor = 'grab';

            }
        }



        // =============================================================================
        // DATA EXTRACTION AND MANAGEMENT
        // =============================================================================
        function extractCorridorsWallsAndWaypoints() {
            corridors = [];
            walls = [];
            waypoints = [];

            for (let i = 0; i < viewer.objects.getObjectCount(); i++) {
                const mapType = viewer.objects.mapTypes[i];
                const bounds = viewer.objects.getBounds(i);
                const objectId = viewer.objects.getObjectId(i);
                const label = viewer.objects.labels[i];

                switch (mapType) {
                    case 'corridor':
                        corridors.push({ id: objectId, ...bounds, rotation: viewer.objects.extra[i]?.rotation || 0 });
                        break;
                    case 'wall':
                        walls.push({ id: objectId, ...bounds, rotation: viewer.objects.extra[i]?.rotation || 0 });
                        break;
                    case 'waypoint':
                    case 'warppoint':
                        waypoints.push({
                            id: objectId,
                            label: label || '',
                            x: bounds.x + bounds.width / 2,
                            y: bounds.y + bounds.height / 2,
                            type: mapType,
                            portalId: viewer.objects.extra[i]?.portalId || null  // warppoint

                        });
                        break;
                }
            }

            console.log(`Found ${corridors.length} corridors, ${walls.length} walls, ${waypoints.length} waypoints`);
            updateWaypointDropdowns();
        }

        function updateWaypointDropdowns() {
            const fromSelect = document.getElementById('from-waypoint');
            const toSelect = document.getElementById('to-waypoint');

            fromSelect.innerHTML = '<option value="">Select waypoint...</option>';
            toSelect.innerHTML = '<option value="">Select waypoint...</option>';

            waypoints.forEach(waypoint => {
                ['from-waypoint', 'to-waypoint'].forEach(selectId => {
                    const option = document.createElement('option');
                    option.value = waypoint.id;

                    option.textContent = waypoint.label
                        ? `${waypoint.id} - ${waypoint.label}`
                        : waypoint.id || 'Unnamed';


                    document.getElementById(selectId).appendChild(option);
                });
            });
        }

        function updateInfo() {
            const updates = {
                'corridor-count': corridors.length,
                'wall-count': walls.length,
                'waypoint-count': waypoints.length,
                'path-count': paths.length,
                'current-size': objectSize
            };

            Object.entries(updates).forEach(([id, value]) => {
                document.getElementById(id).textContent = value;
            });

            if (corridors.length > 0) {
                const minDimension = Math.min(...corridors.map(c => Math.min(c.width, c.height)));
                document.getElementById('min-corridor').textContent = minDimension.toFixed(1);
            }

            const zoom = viewer ? Math.round(viewer.zoom * 100) : 100;
            document.getElementById('zoom-level').textContent = zoom + '%';
        }


        // =============================================================================
        // RENDERING FUNCTIONS
        // =============================================================================
        function drawPaths() {
            if (corridors.length === 0) return;

            const ctx = viewer.ctx;
            ctx.save();
            ctx.scale(viewer.zoom, viewer.zoom);
            ctx.translate(viewer.panX / viewer.zoom, viewer.panY / viewer.zoom);

            paths.forEach((path, index) => {
                const hue = (index * 137.5) % 360;
                const color = `hsl(${hue}, 70%, 50%)`;

                // วาด path หลัก
                ctx.strokeStyle = color;
                ctx.lineWidth = objectSize;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.beginPath();
                path.points.forEach((point, i) => {
                    if (i === 0 || (path.points.teleportSegments && path.points.teleportSegments.includes(i - 1))) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                });
                ctx.stroke();

                // วาด markers
                ctx.fillStyle = color;
                const markerSize = objectSize / 2;
                ctx.fillRect(path.points[0].x - markerSize, path.points[0].y - markerSize, markerSize * 2, markerSize * 2);
                ctx.fillRect(path.points[path.points.length - 1].x - markerSize, path.points[path.points.length - 1].y - markerSize, markerSize * 2, markerSize * 2);
            });

            ctx.restore();

            // วาดเส้นประ adjustment
            paths.forEach((path, index) => {
                const hue = (index * 137.5) % 360;
                const color = `hsl(${hue}, 70%, 50%)`;

                if (path.fromOriginal && path.fromAdjusted) {
                    drawAdjustmentIndicator(path.fromOriginal, path.fromAdjusted, color);
                }
                if (path.toOriginal && path.toAdjusted) {
                    drawAdjustmentIndicator(path.toOriginal, path.toAdjusted, color);
                }
            });
        }

        function drawAdjustmentIndicator(original, adjusted, color) {
            const ctx = viewer.ctx;
            const distance = Math.sqrt(
                Math.pow(original.x - adjusted.x, 2) +
                Math.pow(original.y - adjusted.y, 2)
            );

            if (distance <= 1) return;

            ctx.save();
            ctx.scale(viewer.zoom, viewer.zoom);
            ctx.translate(viewer.panX / viewer.zoom, viewer.panY / viewer.zoom);




            ctx.strokeStyle = color;
            ctx.lineWidth = 2 / viewer.zoom;
            ctx.setLineDash([3 / viewer.zoom, 3 / viewer.zoom]);

            // Use refactored straight line logic
            const linePath = createStraightLinePath(original, adjusted, walls);

            if (linePath.length > 1) {
                ctx.beginPath();
                ctx.moveTo(linePath[0].x, linePath[0].y);
                for (let i = 1; i < linePath.length; i++) {
                    ctx.lineTo(linePath[i].x, linePath[i].y);
                }
                ctx.stroke();
            }

            ctx.setLineDash([]);

            // Draw start and end points
            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 1 / viewer.zoom;

            ctx.beginPath();
            ctx.arc(original.x, original.y, 3 / viewer.zoom, 0, Math.PI * 2);
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(adjusted.x, adjusted.y, 3 / viewer.zoom, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }


        function getMapBounds() {
            const allObjects = [...corridors, ...walls];
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            allObjects.forEach(obj => {
                minX = Math.min(minX, obj.x);
                minY = Math.min(minY, obj.y);
                maxX = Math.max(maxX, obj.x + obj.width);
                maxY = Math.max(maxY, obj.y + obj.height);
            });

            return { minX, minY, width: maxX - minX, height: maxY - minY };
        }

        function drawCorridorBuffers() {

            const ctx = viewer.ctx;
            const halfSize = objectSize / 2;

            ctx.save();
            ctx.scale(viewer.zoom, viewer.zoom);
            ctx.translate(viewer.panX / viewer.zoom, viewer.panY / viewer.zoom);

            if (showCorridors) {
                // วาด corridor (สีเหลือง)
                ctx.fillStyle = 'rgba(255, 255, 0, 0.2)';
                corridors.forEach(corridor => {
                    if (corridor.rotation && corridor.rotation !== 0) {
                        ctx.save();
                        const cx = corridor.x + corridor.width / 2;
                        const cy = corridor.y + corridor.height / 2;
                        ctx.translate(cx, cy);
                        ctx.rotate(corridor.rotation * Math.PI / 180);
                        ctx.fillRect(-corridor.width / 2, -corridor.height / 2, corridor.width, corridor.height);
                        ctx.restore();
                    } else {
                        ctx.fillRect(corridor.x, corridor.y, corridor.width, corridor.height);
                    }
                });

                // วาด safe area (สีเขียว) - ต้องหมุนด้วยถ้า corridor หมุน
                ctx.fillStyle = 'rgba(0, 255, 0, 0.4)';
                corridors.forEach(corridor => {
                    const safeWidth = corridor.width - objectSize;
                    const safeHeight = corridor.height - objectSize;

                    if (safeWidth > 0 && safeHeight > 0) {
                        if (corridor.rotation && corridor.rotation !== 0) {
                            ctx.save();
                            const cx = corridor.x + corridor.width / 2;
                            const cy = corridor.y + corridor.height / 2;
                            ctx.translate(cx, cy);
                            ctx.rotate(corridor.rotation * Math.PI / 180);
                            ctx.fillRect(-safeWidth / 2, -safeHeight / 2, safeWidth, safeHeight);
                            ctx.restore();
                        } else {
                            ctx.fillRect(
                                corridor.x + halfSize,
                                corridor.y + halfSize,
                                safeWidth,
                                safeHeight
                            );
                        }
                    }
                });

                // วาดจุดสีน้ำเงิน
                const pathfinder = new OrthogonalPathfinder(corridors, walls, gridSize, objectSize);
                ctx.fillStyle = 'rgba(0, 0, 255, 1)';

                for (let y = 0; y < pathfinder.rows; y++) {
                    for (let x = 0; x < pathfinder.cols; x++) {
                        if (pathfinder.grid[y][x].walkable) {
                            const worldX = pathfinder.grid[y][x].worldX;
                            const worldY = pathfinder.grid[y][x].worldY;
                            ctx.beginPath();
                            ctx.arc(worldX, worldY, 2 / viewer.zoom, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            }

            if (showWalls) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                walls.forEach(wall => {
                    ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
                });
            }

            if (showWaypoints) {
                const pathfinder = new OrthogonalPathfinder(corridors, walls, gridSize, objectSize);
                ctx.lineWidth = 1 / viewer.zoom;

                waypoints.forEach(waypoint => {
                    const canPlace = pathfinder.canPlaceObjectAt(waypoint.x, waypoint.y);

                    ctx.fillStyle = canPlace ? 'rgba(100, 255, 100, 0.6)' : 'rgba(255, 100, 100, 0.8)';
                    ctx.strokeStyle = canPlace ? 'rgba(0, 255, 0, 1)' : 'rgba(255, 0, 0, 1)';

                    ctx.fillRect(waypoint.x - halfSize, waypoint.y - halfSize, objectSize, objectSize);
                    ctx.strokeRect(waypoint.x - halfSize, waypoint.y - halfSize, objectSize, objectSize);

                    if (!canPlace) {
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 3 / viewer.zoom;
                        ctx.beginPath();
                        ctx.moveTo(waypoint.x - halfSize + 2, waypoint.y - halfSize + 2);
                        ctx.lineTo(waypoint.x + halfSize - 2, waypoint.y + halfSize - 2);
                        ctx.moveTo(waypoint.x + halfSize - 2, waypoint.y - halfSize + 2);
                        ctx.lineTo(waypoint.x - halfSize + 2, waypoint.y + halfSize - 2);
                        ctx.stroke();
                    }

                    ctx.fillStyle = 'rgba(255, 0, 0, 1)';
                    ctx.beginPath();
                    ctx.arc(waypoint.x, waypoint.y, 3 / viewer.zoom, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw waypoint label
                    ctx.fillStyle = 'black';
                    ctx.font = `${12 / viewer.zoom}px Arial`;
                    let displayText = '';
                    if (waypoint.type === 'warppoint' && waypoint.portalId) {
                        displayText = waypoint.label ? waypoint.label : waypoint.portalId;
                    } else if (waypoint.label) {
                        displayText = waypoint.label;
                    } else {
                        displayText = waypoint.id;
                    }

                    ctx.fillText(displayText, waypoint.x + halfSize + 5, waypoint.y - halfSize - 5);
                });
            }


            ctx.restore();
        }

        // =============================================================================
        // PUBLIC API FUNCTIONS
        // =============================================================================
        window.loadFile = function () {
            const fileInput = document.getElementById('file-input');
            const file = fileInput.files[0];

            if (!file) {
                alert('Please select a JSON file');
                return;
            }

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    // เคลียร์ข้อมูลเดิมก่อน load ไฟล์ใหม่
                    corridors = [];
                    walls = [];
                    waypoints = [];
                    paths = [];
                    showDebug = false;
                    contextMenuVisible = false;
                    isPanning = false;
                    objectSize = 5;

                    // เคลียร์ temp waypoints
                    window.tempFromPoint = null;
                    window.tempToPoint = null;

                    // เคลียร์ dropdown selections
                    document.getElementById('from-waypoint').value = '';
                    document.getElementById('to-waypoint').value = '';

                    // ลบ temp options
                    removeTemporaryOptions('temp_from_');
                    removeTemporaryOptions('temp_to_');

                    // Clear originalPositions cache
                    if (viewer.objects.originalPositions) {
                        delete viewer.objects.originalPositions;
                    }



                    document.getElementById('object-size').value = 5;
                    document.getElementById('size-value').textContent = '5px';

                    hideContextMenu();

                    const mapData = JSON.parse(e.target.result);
                    viewer.loadMapData(mapData);
                    extractCorridorsWallsAndWaypoints();

                    // visibility ตาม checkbox state
                    viewer.setVisibility('corridors', document.getElementById('show-corridors').checked);
                    viewer.setVisibility('walls', document.getElementById('show-walls').checked);
                    viewer.setVisibility('waypoints', document.getElementById('show-waypoints').checked);
                    viewer.setVisibility('warppoints', document.getElementById('show-warppoints').checked);
                    viewer.setVisibility('images', document.getElementById('show-images').checked);
                    updateInfo();
                } catch (error) {
                    alert('Error loading JSON: ' + error.message);
                }
            };
            reader.readAsText(file);
        };

        window.loadSample = function () {
            const sampleData = {
                version: 1,
                objects: [
                    { id: 1, type: "rectangle", mapType: "corridor", x: 200, y: 100, w: 400, h: 20, color: "#f39c12", label: "", objectId: "main_corridor", extra: null },
                    { id: 2, type: "rectangle", mapType: "corridor", x: 200, y: 100, w: 20, h: 200, color: "#f39c12", label: "", objectId: "side_corridor", extra: null },
                    { id: 3, type: "circle", mapType: "waypoint", x: 250, y: 100, w: 16, h: 16, color: "#e74c3c", label: "", objectId: "start", extra: null },
                    { id: 4, type: "circle", mapType: "waypoint", x: 550, y: 100, w: 16, h: 16, color: "#e74c3c", label: "", objectId: "end", extra: null },
                    { id: 5, type: "rectangle", mapType: "wall", x: 300, y: 80, w: 100, h: 20, color: "#2c3e50", label: "", objectId: "wall1", extra: null }
                ]
            };

            viewer.loadMapData(sampleData);
            extractCorridorsWallsAndWaypoints();
            updateInfo();
        };

        window.findPaths = function () {
            if (corridors.length === 0) {
                alert('Need corridors to find paths');
                return;
            }

            const fromWaypointId = document.getElementById('from-waypoint').value;
            const toWaypointId = document.getElementById('to-waypoint').value;

            if (!fromWaypointId || !toWaypointId) {
                alert('Please select both from and to waypoints');
                return;
            }

            if (fromWaypointId === toWaypointId) {
                alert('Please select different source and destination waypoints');
                return;
            }

            // Handle temp waypoints or regular waypoints
            let fromWaypoint, toWaypoint;

            if (fromWaypointId.startsWith('temp_from_')) {
                fromWaypoint = window.tempFromPoint;
            } else {
                fromWaypoint = waypoints.find(w => w.id === fromWaypointId);
            }

            if (toWaypointId.startsWith('temp_to_')) {
                toWaypoint = window.tempToPoint;
            } else {
                toWaypoint = waypoints.find(w => w.id === toWaypointId);
            }

            console.log(`Finding path with object size: ${objectSize}`);
            paths = [];
            viewer.render();


            // ปรับ gridSize ตาม rotation
            const maxRotation = Math.max(...corridors.map(c =>
                Math.abs(c.rotation || 0)
            ));

            // ถ้าเอียงมาก ใช้ grid หยาบขึ้น
            let adaptiveGridSize = gridSize;
            if (maxRotation > 40) adaptiveGridSize = 10;  // ลดลงจาก 25
            else if (maxRotation > 30) adaptiveGridSize = 8;   // ลดลงจาก 20
            else if (maxRotation > 15) adaptiveGridSize = 7;   // ลดลงจาก 15

            console.log(`Finding path with grid size: ${adaptiveGridSize}, object size: ${objectSize}`);

            const pathfinder = new OrthogonalPathfinder(corridors, walls, adaptiveGridSize, objectSize);


            if (!fromWaypoint || !toWaypoint) {
                alert('Selected waypoints not found');
                return;
            }

            const fromPos = pathfinder.canPlaceObjectAt(fromWaypoint.x, fromWaypoint.y)
                ? fromWaypoint
                : findNearestCorridorPosition(fromWaypoint, corridors, walls, adaptiveGridSize, objectSize);

            const toPos = pathfinder.canPlaceObjectAt(toWaypoint.x, toWaypoint.y)
                ? toWaypoint
                : findNearestCorridorPosition(toWaypoint, corridors, walls, adaptiveGridSize, objectSize);

            const path = pathfinder.findPath(fromPos, toPos);
            if (path) {
                paths.push({
                    from: fromWaypointId,
                    to: toWaypointId,
                    points: path,
                    fromOriginal: fromWaypoint,
                    toOriginal: toWaypoint,
                    fromAdjusted: fromPos,
                    toAdjusted: toPos
                });

                console.log(`Found path from ${fromWaypointId} to ${toWaypointId}`);
            } else {
                // ลองหา portal path
                const portalPath = findPortalPath(fromPos, toPos, pathfinder, waypoints);
                if (portalPath) {
                    paths.push({
                        from: fromWaypointId,
                        to: toWaypointId,
                        points: portalPath,
                        fromOriginal: fromWaypoint,
                        toOriginal: toWaypoint,
                        fromAdjusted: fromPos,
                        toAdjusted: toPos,
                        usedPortal: true
                    });
                    console.log(`Found portal path from ${fromWaypointId} to ${toWaypointId}`);
                } else {
                    alert(`No path found from ${fromWaypointId} to ${toWaypointId}`);
                }
            }

            viewer.render();
        };

        window.clearPaths = function () {
            paths = [];
            showDebug = false;
            document.getElementById('from-waypoint').value = '';
            document.getElementById('to-waypoint').value = '';

            // Remove temp options and clear temp points
            removeTemporaryOptions('temp_from_');
            removeTemporaryOptions('temp_to_');

            window.tempFromPoint = null;
            window.tempToPoint = null;

            viewer.render();
            updateInfo();
        };

        window.toggleDebug = function () {
            showDebug = !showDebug;
            viewer.render();
        };

        setInterval(() => {
            if (viewer) {
                const zoom = Math.round(viewer.zoom * 100);
                const currentZoom = document.getElementById('zoom-level').textContent;
                if (currentZoom !== zoom + '%') {
                    updateInfo();
                }
            }
        }, 100);
    </script>
</body>

</html>